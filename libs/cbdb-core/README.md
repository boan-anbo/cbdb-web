# @cbdb/core - Shared Types & Contracts Library

## Architectural Layers & Data Flow

### System Architecture Layers

Our system follows a strict layered architecture with clear data type boundaries:

```
┌─────────────────────────────────────────────────────┐
│                   Client                            │
├─────────────────────────────────────────────────────┤
│              Controller Layer                        │
│                  (DTOs only)                        │
├─────────────────────────────────────────────────────┤
│               Service Layer                         │
│              (Messages only)                        │
├─────────────────────────────────────────────────────┤
│              Repository Layer                       │
│           (Schemas → Models)                        │
├─────────────────────────────────────────────────────┤
│              Database Layer                         │
│            (Raw Schemas only)                       │
└─────────────────────────────────────────────────────┘
```

### Layer Contracts

| Layer | Input | Output | Data Types Used |
|-------|-------|--------|-----------------|
| **Database** | SQL | Raw Records | Schemas only |
| **Repository** | Schemas | Models | Schemas + Models |
| **Service** | Messages | Messages | All Messages (Models, CQRS, DataViews) |
| **Controller** | DTOs | DTOs | DTOs only |
| **Client** | JSON | UI | TypeScript types |

### Messages - The Universal Data Language

**Messages** are ALL data structures that flow through the system above the schema layer:

```
Messages
├── Models (Database Entities)
│   ├── TableModel    - Raw table representation
│   ├── Model         - Entity with denormalized data (DEFAULT)
│   └── ExtendedModel - Entity with all relations
├── DTOs (API Contracts)
│   ├── Requests      - API input contracts
│   └── Responses     - API output contracts
├── CQRS (Service Operations)
│   ├── Queries       - Read operation requests
│   ├── Commands      - Action operation requests
│   ├── Results       - Operation responses
│   └── Events        - Domain events
└── DataViews (Compositions)
    └── Purpose-specific data shapes
```

## Data Modeling Hierarchy

### 1. Schema Layer (Database Level)
**Location**: `/schemas/`
**Access**: Repository layer ONLY
**Contract**:
- Raw database table interfaces
- Generated by Drizzle from SQLite
- TypeScript compile-time only
- Never exposed above repository

### 2. TableModel (Raw Tables)
**Location**: `/domains/*/models/*.model.table.ts`
**Access**: Repository internal
**Contract**:
- 1:1 mapping to database tables
- NO joins, NO relations
- Constructor-based classes
- Example: `PersonTableModel`

### 3. Model (Business Entity - DEFAULT)
**Location**: `/domains/*/models/*.model.ts`
**Access**: Repository → Service → Controller
**Contract**:
- TableModel + trivial joins (code tables)
- Includes human-readable denormalized values
- The default that developers expect
- Example: `PersonModel` with dynasty names

### 4. ExtendedModel (Complete Entity)
**Location**: `/domains/*/models/*.model.extended.ts`
**Access**: Service layer primarily
**Contract**:
- Model + all entity relations
- Uses composition pattern
- Relations are ALWAYS arrays ([] for empty)
- Example: `PersonFullExtendedModel`

### 5. DataView (Composed Data)
**Location**: `/domains/*/views/*.data-view.ts`
**Access**: Service layer
**Contract**:
- Purpose-specific compositions
- Combines multiple models/sources
- Tailored for UI/analytics needs
- Example: `PersonTimelineDataView`

### 6. DTO (HTTP Contract)
**Location**: `/domains/*/messages/*.dtos.ts`
**Access**: Controller layer ONLY
**Contract**:
- Request/Response structures
- Validation decorators
- API metadata
- Thin wrapper around Results

### 7. CQRS (Service Language)
**Location**: `/domains/*/messages/*.cqrs.ts`
**Access**: Service layer
**Contract**:
- Standard service operation language
- Queries for reads, Commands for actions
- Results for responses
- Events for domain notifications

## Naming Conventions

### Models
- **TableModel**: `[Domain]TableModel` (e.g., `PersonTableModel`)
- **Model**: `[Domain]Model` (e.g., `PersonModel`)
- **ExtendedModel**: `[Domain]ExtendedModel` or `[Domain]FullExtendedModel`
- **DataView**: `[Domain][Purpose]DataView` (e.g., `PersonTimelineDataView`)

### Messages (CQRS)
- **Query**: `[Domain][Action]Query` (e.g., `PersonSearchQuery`)
- **Command**: `[Domain][Action]Command` (e.g., `ExportDataCommand`)
- **Result**: `[Domain][Action]Result` (e.g., `PersonSearchResult`)
- **Event**: `[Domain][Action]Event` (e.g., `PersonCreatedEvent`)

### DTOs
- **Request**: `[Action][Domain]Request` (e.g., `SearchPersonRequest`)
- **Response**: `[Domain][Action]Response` (e.g., `PersonSearchResponse`)

### Repository Methods
- **TableModel**: `get[Domain]TableModel()`
- **Model**: `get[Domain]Model()` or `findModelById()`
- **ExtendedModel**: `get[Domain]ExtendedModel()` or `findFullExtendedModelById()`
- **Batch**: `findByIds()`, `batchGet()`

## Key Architectural Rules

### 1. Layer Isolation
- **Controllers** NEVER access Schemas or Models directly
- **Services** NEVER access Schemas
- **Repositories** are the ONLY layer that accesses Schemas
- **Database** layer only knows Schemas

### 2. Data Type Boundaries
- **DTOs** exist ONLY in Controllers
- **CQRS Messages** exist ONLY in Services
- **Models** flow from Repository → Service → Controller
- **Schemas** NEVER leave Repository

### 3. Composition Pattern
```typescript
// ExtendedModel uses composition, NOT inheritance
export class PersonFullExtendedModel {
  public person: PersonModel;              // Core entity
  public fullRelations: PersonFullRelations;  // All relations

  constructor(person: PersonModel, relations: PersonFullRelations) {
    this.person = person;
    this.fullRelations = relations;
  }
}
```

### 4. Default Assumptions
- **Model** is the DEFAULT - what developers expect
- Relations are ALWAYS arrays (never undefined)
- Empty relations return `[]` not `null`
- Use composition over inheritance

## Directory Structure

```
@cbdb/core/
├── schemas/                 # Database schemas (Repository access only)
├── domains/
│   ├── person/
│   │   ├── models/
│   │   │   ├── person.model.table.ts      # TableModel
│   │   │   ├── person.model.ts            # Model (DEFAULT)
│   │   │   └── person.model.extended.ts   # ExtendedModel
│   │   ├── views/
│   │   │   └── person-timeline.data-view.ts
│   │   ├── messages/
│   │   │   ├── person.dtos.ts            # DTOs (Controller)
│   │   │   └── person.cqrs.ts            # CQRS (Service)
│   │   └── person.mapper.ts              # Mapping logic
│   └── [other domains...]
├── endpoints/               # API endpoint definitions
└── client/                  # TypeScript HTTP clients
```

## Testing Strategy

Each layer requires different testing approaches:

| Layer | Test Focus | Test Type |
|-------|------------|-----------|
| Schema | N/A (Generated) | - |
| Repository | Schema → Model mapping | Integration |
| Service | Business logic with Messages | Unit + Integration |
| Controller | DTO validation, HTTP contracts | Integration |
| Client | API calls | Integration |

## Quick Reference

### What goes where?
- **Database logic** → Repository
- **Business logic** → Service
- **HTTP logic** → Controller
- **Validation** → DTOs (Controller layer)
- **Mapping** → Repository (via cbdbMapper)

### What uses what?
- **Repository**: Schemas → Models
- **Service**: Messages (all types)
- **Controller**: DTOs only
- **Client**: TypeScript interfaces

### Common patterns:
```typescript
// Repository
async findModelById(id: number): Promise<PersonModel> {
  const record = await db.select().from(BIOG_MAIN)...
  return cbdbMapper.person.toModel(record, denormData);
}

// Service
async getPersonDetail(query: PersonGetQuery): Promise<PersonGetResult> {
  const model = await this.repository.findModelById(query.id);
  return new PersonGetResult(model);
}

// Controller
@Get(':id')
async getPersonDetail(@Param() params: GetPersonRequest): Promise<PersonResponse> {
  const query = new PersonGetQuery(params.id);
  const result = await this.service.getPersonDetail(query);
  return new PersonResponse(result);
}
```